## 各种初始化
```
A a;  // 【推荐】默认构造函数；
A b = A{};  // 【不推荐】仅有一次构造（默认构造函数），不要误认为书写了`=`就会发生两次构造；因为gcc默认是有返回值优化的（使用-fno-elide-constructors关闭，c++17之后强制优化关不掉），但是这种涉及优化的情况，容易把持不住，出现诡异的现象；
A c = a;  // 仅有一次构造（复制构造函数），未发生“赋值”操作，不要误认为书写了`=`就会发生赋值；
A d(a);  // 【推荐】仅有一次构造（复制构造函数）
A e{a};  // 【不推荐】仅有一次构造（复制构造函数），大括号“统一”初始化语法，（不推荐用法-见报错1），但是在下例C++最令人苦恼之解析语法的场景下，还是可以临时使用来避免歧义的；
e = a;  // 【推荐】仅有一次构造/调用（复制赋值运算符）
A f();  // C++最令人苦恼之解析语法，没有发生任何构造，仅仅声明了一个返回类型为A的函数（C++规定：优先解析为声明）；
A g(std::move(a));  // 【推荐】仅有一次构造（移动构造函数）
g = std::move(a);  // 【推荐】仅有一次构造/调用（移动赋值运算符）
如果使用函数返回值来进行赋值/初始化，参见[函数返回值]
```

## 6种特殊成员函数：（可以以函数符号或者内联的方式-见例1【自动生成(defaulted/implicit)】（不需要用户写函数签名）的成员函数），这6种都可以说是【构造】行为，但不是【分配】行为，分配行为是函数栈帧内给该对象分配位置而构造行为是调用该对象的什么函数，ps：如何判断某函数是否被生成，使用nm/objdump命令查看：有函数符号或者对应的内联代码；

|特殊成员函数|函数符号（内联时看不到）|自动生成机制的前提：<br>- 1.必须是代码中有用到（如果没使用的话就算定义了也不会生成）；<br>- 2.必须是未【用户声明】（用户写函数签名，函数体为【用户实现】（例如A() {}）或【默认实现】（例如A() = default;）或未实现（例如A();））的；<br>- 3.要求非POD成员变量必须也要有能被该自动生成的函数所【调用匹配】（附1）的函数（自动生成的也可以）-具体描述见附2；<br>- 4.同时要满足如下机制<hr>|
|-|-|:---|
|默认构造函数|A() 函数符号为\_ZN1AC1Ev或者\_ZN1AC2Ev|- 没有用户声明的任何【构造函数】（构造函数有很多种，自定义参数的也算，运算符重载不算构造函数）；<br>- ps：类似默认实现的骚操作有delete，可以禁止一个函数被生成，例如禁止拷贝赋值A& operator = (const A&) = delete;|
|析构函数|~A() 函数符号为\_ZN1AD1Ev|
|复制构造函数|<hr>A(const A&) 函数符号为\_ZN1AC1ERKS\_<br>A(A&)函数符号为\_ZN1AC1ERS\_|<hr>- 没有用户声明的【移动操作】（移动构造函数和移动赋值运算符）和复制构造函数（包括const的和非const的）；<br>- 自动生成时，优先尝试只生成const的复制构造函数，否则尝试只生成非const的复制构造函数；<br>- ps: 复制构造函数形参是否应该const，暂定没有特殊情况应该const;|
|复制赋值运算符|<hr>A& operator=(const A&) 函数符号为\_ZN1AaSERKS\_<br>A& operator=(A&) 函数符号为\_ZN1AaSERS\_<br>- ps：用户实现的类似{ ...; return *this; }|<hr>- 没有用户声明的移动操作和复制赋值运算符（包括const的和非const的）；<br>- 自动生成时，优先尝试只生成const的复制赋值运算符，否则尝试只生成非const的复制赋值运算符；<br>- ps: 通常和复制构造函数的行为应该保持一致，所以定义一个也应该定义另一个，不过通常情况下自动生成的应该可以满足需求；|
|移动构造函数|<hr>~A(const A&&) 函数符号为\_ZN1AC1EOKS\_（const参数的只能通过用户实现，不能通过默认实现或自动生成，所以这里划掉了）~<br>A(A&&) 函数符号为\_ZN1AC1EOS\_|<hr>- 没有用户声明的【复制操作】（复制构造函数和复制赋值运算符）、移动操作、析构函数；<br>- *如果无法自动生成移动构造函数（但是代码中又有用到类似`A b(std::move(a));`这样），编译器会尝试自动生成const复制构造函数-见例3；<br>- ps: 可以使用std::is_move_constructible<A>::value;返回true来判断一个类支持std::move的用法，但并不代表这个类自动生成了移动操作函数，也有可能因为这个类有const的复制构造函数；|
|移动赋值运算符|<hr>~A& operator=(const A&&) 函数符号为\_ZN1AaSEOKS\_（只能通过用户实现）~<br>A& operator=(A&&) 函数符号为\_ZN1AaSEOS\_|<hr>- 没有用户声明的复制操作、移动操作、析构函数；<br>- *如果无法自动生成移动赋值运算符（但是代码中又有用到类似`b = std::move(a);`这样），编译器会尝试自动生成const复制赋值运算符；|

### 附1：
- 调用匹配规则：右值引用参数、const左值引用参数和非const左值引用参数的函数可以同时存在，调用时优先调用匹配参数相同的，const左值引用参数的函数，可以万能匹配（这三种调用都可以匹配）；
- 自动生成和默认实现的函数内容其实就是：对POD的成员函数直接普通初始化，非POD的则按照调用匹配规则来调用其函数；例如A类有成员变量b（type 是 B），A类自动生成的函数参数是什么类型的，那么就按照什么类型的b去调用能匹配的B的函数来给b初始化；

### 附2：
- 要想自动生成默认构造函数，那每个非POD的成员变量也必须要有默认构造函数（自动生成的也可以）；
- 要想自动生成非const的复制构造函数，那每个非POD成员变量必须要么有（或者能自动生成）非const的复制构造函数，要么有（或者能自动生成）const的复制构造函数；
- 要想自动生成const的复制构造函数，那每个非POD成员变量必须有（或者能自动生成）const的复制构造函数；
- 要想自动生成const的复制赋值运算符，那每个非POD成员变量必须也要有（或者能自动生成）const的复制赋值运算符；
- 要想自动生成非const的移动赋值运算符，那每个非POD成员变量必须要么有（或者能自动生成）非const的移动赋值运算符，要么有（或者能自动生成）const的移动赋值运算符，要么有（或者能自动生成）const的复制赋值运算符；
- 以此类推；

## Q
_ZN1AC5Ev是什么符号 notype local