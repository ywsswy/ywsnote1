## 结论（仅考虑传递的是函数局部变量）：
- 性能角度`A Fun()`肯定不如`void Fun(A& a)，就算有编译器返回值优化尽量减少默认构造和移动赋值的开销也顶多做到二者持平，所以追求性能的话，无脑用第二种【输出参数】就是了；

- 代码易用性角度的话，可以适当采用第一种【函数返回值】，但是第一种的写法有很多形式，需要搞懂是否符合预期以及对性能的影响；我的【期望】是最多函数外初始化一次（小开销构造），函数内大开销构造一次，函数返回时移动一次（中开销），如果能减少函数外初始化或者函数返回时的移动，都是优于预期的写法；


- 【一般函数】指声明返回值类型为非引用的函数（A Fun2(); 或者 A operator+(const A&)）；非一般函数（A& Fun2(); 或者 A&& Fun2();）相当于会存在返回裸引用问题，需要小心操作的是不是局部变量；

- return语句如果是左值（`A Fun() {A b; return b;}`），编译器会优化成函数内部显式构造的其实是外部栈帧上分配的变量，所以性能符合期望（见上述对期望的说明），看调用处`A a; a = Fun();`的汇编实现是：

```
1. 构造a；
2. 分配（分配与构造的区别见上级目录）临时tmp_for_Fun；
3. 对tmp_for_Fun调用（push+callq）Fun函数；
4. Fun内构造tmp_for_Fun；
5. Fun结束（leaveq+retq）后把tmp_for_Fun移动给a；
6. 析构tmp_for_Fun；
7. 执行后续逻辑；
8. 析构a；
```

- 如果写成`A a(Fun());` 会被编译器极致优化成整体只发生一次构造（连移动操作都优化掉了）；但是如果有很多个分支的return语句各自返回不同的左值时（`if(x) return b; return c;`），编译器就没办法优化了（不知道外部栈帧留多少，总不能每个变量都给吧），只能多发生一次隐式移动构造来接收每个分支的return语句，所以最好函数内只返回一种左值；

- return语句如果是一般函数（`A Fun() {A b; return b + 3;}  // 重载+的函数`）时？？{A b; A c(b+3); return c;}
- return语句如果是非一般函数的rvalue时，函数内部多发生一次隐式移动构造，例如`A b; return std::move(b);`编译器会自动补全成：`A b; A tmp_move(std::move(b)); return tmp_move;`性能差；（ps：这个隐式构造的tmp_move是外部栈帧的变量）

- 不要在函数调用处包一层右值转换（A&& a = std::move(Fun());），函数表达式已经相当于是右值了，多一次move反而会导致出错，跟`A&& a = Fun();`相比并没有延长函数返回值的生命周期，推测是因为这句话里面出现了两层右值（`Fun()`是第一层右值，`std::move(...)`是第二层右值），a只延长了第二层右值的生命周期，没有延长第一层右值的生命周期，所以执行完这句话之后Fun()以为自己可以死了，就析构导致了 【“野”引用】：dangling reference（野指针：dangling pointer）；而`A&& a = Fun();`就一层所以能延长Fun()的生命周期，优秀！


## Q：
- std::move(std::move(x));
函数栈帧都消亡了，为什么右值引用能延长生命周期。。。
- 函数返回值有多个的时候怎么写？是std::option，还是tuple，还是用输出参数？