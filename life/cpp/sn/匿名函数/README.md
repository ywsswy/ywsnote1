//[捕获列表](参数列表)->返回类型{函数体}
```
#include <iostream>
int main() {
	auto Add = [](int a, int b)->int {
		return a + b;
	};
        // Add的类型是 int(*)(int, int)，相当于函数指针
	std::cout << Add(1, 2) << std::endl;
	return 0;
}
```
// 编译器可以自动推断出lambda表达式的返回类型，所以我们可以不指定返回类型
// [捕获列表](参数列表){函数体}
// 如果参数列表是空的，可以省略成为
// [捕获列表]{函数体}

哪些参数放在捕获列表里，哪些放在参数列表里呢，取决于调用方是否需要关心参数，如果不需要调用方关注，那全都在定义的时候通过捕获列表来自己维护即可。
Lambda表达式是通过生成一个小class实现的，这个类重载了operater（）函数，所以它的行为非常像一个函数。Lambda函数就是这个class的实例；当这个类构造时，上下文中的任何变量都可以传进Lambda function class，并作为成员变量保存起来

哪些传递是值传递，哪些是引用传递
[]不捕获任何变量
[=]值捕获外部作用域所有变量（偷懒的写法）
[&]引用捕获外部作用域所有变量（偷懒的写法）
[a]值捕获a变量
[&a]引用捕获a变量，推荐，但是要确保是否面临a被外部析构的情况
[this]捕获当前类中的this指针
[b = a.value]某个表达式捕获赋值给b，此时b的值跟a就没有关系了，不存在引用的可能性了；