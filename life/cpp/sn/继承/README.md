-	成员可以访问其类的任意成员，对象仅可以访问其类的public成员（访问开放度：public > protected > private）；
-	成员的访问开放度要逐层计算，每一次继承都不会提高成员的访问开放度（一个public成员经过private继承后，在子类中它就成了private成员）；
-	private成员不会继承给子类（自然就不会被子类的成员和对象访问到）；


其他：
-	成员和对象访问其父类成员的写法是\<class_name>::\<mem_name>和.\<class_name>::\<mem_name>；如果自己跟父类有成员同名时必须这么写（包括变量、函数间的重载和隐藏），无同名时如果仅写\<mem_name>需要判断访问的是哪个父类的成员，要从子类开始往上找，一直找到首次出现该成员的父类；
-	成员函数相关的术语：overload/重载（这个跟继承没关系，只要同名不同参就算）；隐藏：自己跟父类间有同名成员函数就会隐藏（但是仍可通过上述方法访问）父类成员；override/覆盖（通过类型兼容规则要求的虚函数+public继承实现的包含多态：子类指针赋值给父类指针，父类指针调用子类方法）；
- 	判断继承后是否成功override，要从继承树的祖先开始看，一直检查到父类（含父类）中该函数是否声明virtual，否则仅仅是普通隐藏（只要父类写了，子类写不写都行）；要想借助编译器保证的话，只有一个类写override关键字不够的（这只能保证它的一代父类肯定是virtual，实际使用时可能是跨代指针赋值的，所以必须每一次继承都写明override）；更好的习惯是所有有可能多态的成员函数尽早在基类声明virtual；
-	父类（不管是成员还是对象）访问不了子类的变量：只有虚函数，没有虚变量，因为就算同一个类的变量值也可以不同（一定意义上说变量本身就是多态的，每个对象都有自己的内存，不像函数地址共用）
-	类型转换时，子类指针转换为父类是安全的（编译器允许隐式转换），反之不安全（虽然可以显式使用static_cast<子类* >，这时需要程序员保证这个指针当初是new子类new出来的）（dynamic_cast相比static_cast会增加安全校验，但是设计不合理才会需要动态判定，所以不推荐使用，如果是智能指针，则要用xxxxx_pointer_cast）（ref：另外两种cast：const int* p = &a; *(const_cast<int*>(p)) = 6; reinterpret_cast是逐bit位拷贝）
-	多态的分类1：重载多态、强制多态、包含多态、参数多态
-	多态的分类2：编译时多态：如模板特例化和函数重载；运行时多态：如虚函数；
-	静态绑定：编译连接阶段确定操作对象（标识符名和其对应的存储地址）；动态绑定：相反；


 虚函数表
Base::function 如果地址都被覆盖了，这种为什么可以呢
https://blog.csdn.net/sinat_35261315/article/details/53766739