-	成员内可以访问其类的任意成员，对象仅可以访问其类的public成员（访问开放度：public > protected > private）；
-	private成员不允许被子类的成员和对象访问到（只是编码时的限制，但成员变量是物理存在的，能访问到的成员函数也是相同的指令地址，所以会出现“成员变量访问不到，但是成员函数能访问到，然后可以通过这个成员函数来间接访问那个成员变量”的情况）；
-	成员的访问开放度要逐层计算，每一次继承都不会提高成员的访问开放度（一个public成员经过private继承后，子类使用时访问就相当于访问子类的private成员而孙子类无法访问）；


其他：
-	成员和对象访问其父类成员的写法是\<class_name>::\<mem_name>和.\<class_name>::\<mem_name>；如果自己跟父类有成员同名时必须这么写（包括变量、函数间的重载和隐藏），无同名时如果仅写\<mem_name>需要判断访问的是哪个父类的成员，要从子类开始往上找，一直找到首次出现该成员的父类；
-	overload/重载：这个跟继承没关系，只要同名不同参就算，就算一个类内的函数间也会存在重载关系；
-	hide/隐藏：自己跟父类间有同名成员函数就会隐藏（但是仍可通过上述方法访问）父类成员，而且隐藏只是一种状态描述，跟重载覆盖并不是互斥的关系；
-	override/覆盖：通过类型兼容规则要求的虚函数+public继承实现的包含多态：子类指针赋值给父类指针，父类指针调用子类方法；
- 	判断继承后是否成功override，要从继承树的祖先开始看，一直检查到父类（含父类）中该函数是否声明virtual，否则仅仅是普通隐藏（只要父类写了virtual关键字，子类写不写都行）；要想借助编译器保证的话，只有一个类写override关键字不够的（这只能保证它的一代父类肯定是virtual，实际使用时可能是跨代指针赋值的，所以必须每一次继承都写明override关键字）；更好的习惯是所有有可能多态的成员函数尽早在基类声明virtual；
-	父类（不管是成员还是对象）访问不了子类的变量：只有虚函数，没有虚变量，因为就算同一个类的变量值也可以不同（一定意义上说变量本身就是多态的，每个对象都有自己的内存，不像函数地址共用）
-	类型转换时，子类指针转换为父类是安全的（编译器允许隐式转换），反之不安全（虽然可以显式使用static_cast<子类* >，注：staic_cast需要程序员保证这个指针当初是new子类new出来的）（dynamic_cast相比static_cast会增加安全校验，但是设计不合理才会需要动态判定，所以不推荐使用，如果是智能指针，则要用xxxxx_pointer_cast）（ref：另外两种cast：const int* p = &a; *(const_cast<int*>(p)) = 6; reinterpret_cast是逐bit位拷贝通常用于指针间转换）
-	静态绑定：编译连接阶段确定操作对象（标识符名和其对应的存储地址）；动态绑定：相反；


 虚函数表
Base::function 如果地址都被覆盖了，这种为什么可以呢
https://blog.csdn.net/sinat_35261315/article/details/53766739