- 每个c++表达式，都有两个属性：类型（type/型别）和值分类（value category）
- 类型，例如int（整数类型） double&（double左值引用类型） float&&（float右值引用类型，c++11才引入的）；
- 值分类，有三种prvalue（纯右值，rvalue（右值（表达式））的一种）, xvalue（将亡值，rvalue的另一种）, (g)lvalue（左值（表达式））；
- <font color=red>也就是说，左值引用可以是左值也可以是rvalue，右值引用同样可以是左值也可以是rvalue；它们是表达式的两个属性；</font>
- 可以取地址的肯定是左值，即可以执行`std::cout << &(x) << std::endl;`（反之rvalue取地址会报错）；
- 可以写在赋值表达式等号左边的肯定是左值（写在右边的不一定）；
- 赋值表达式本身可以理解成是一个左值，例如`(i = 3) = 9;`中，`i`是一个左值，`i = 3`是个赋值表达式，但是它还可以继续用9来赋值；
- `++i`是左值，所以可以写`++i = 3;`；`i++`是rvalue，所以不可以写`i++ = 3;`；
- `A(a)`这个复制构造形式的表达式是rvalue，不只这个，任何函数（包括重载的运算符函数）的返回值肯定是个rvalue；
- A&（左值引用）和A&&（右值引用）都并没有真的在内存中新分配一个A；
- 左值引用所引用的左值的生命周期不会受到左值引用的影响；但是右值引用所引用的右值的生命周期则是跟着一起延长的（没有右值引用的话右值会在其所在的"完整的"表达式结束后消亡掉）；（如何界定“完整”，还不确定）
- 对左值引用进行“读取或者重新赋值”操作就等价于操作其引用的那个左值；
- 对右值引用进行“读取”没问题，但是“重新赋值”相当结束原来所引用的右值的生命周期，然后重新引用一个新的右值；
- && 不一定是右值引用，还可能表示万能引用（需要经过类型推导才能确定的引用），例如`auto&& a = b;`需要推导才能确定是左值引用还是右值引用，还有函数模板中`template <typename T> void f(T&&)`的情况也是需要推导的；
```
auto b = a;  // 不管a是什么，b的值分类是左值，类型不是引用
auto& b = a;  // a是左值时b的值分类是左值引用，a是右值时编译不过
auto&& b = a;  // a是左值时b的值分类是左值引用，a是右值时b的值分类是右值引用，c++11的Range-based for loop中，引用可以写成`for (auto&& it : x)`，此时it是x的一个元素的引用（使用.first或者本身就可以获取元素值），而不是iterator了，如果是用find，才是iterator（需要继续用->first或者*i来访问元素）
auto本身不改变const属性，但是可以人为加上const修饰，不过一旦加上const后，就不是万能引用了，const auto&&要求必须是右值引用
注意Range-based for loop中map的每个元素的first其实是const的。
```
- <font color=red>只能用rvalue来初始化右值引用变量，如果是左值（哪怕是右值引用类型的左值）不能初始化右值引用变量！</font>例如下例b是左值，std::move(b)是rvalue，所以匹配的函数形参是不同的：
```
void f1(int& a) {
  std::cout << "(&)" << std::endl;
}
void f1(int&& a) {
  std::cout << "(&&)" << std::endl;
}
int main() {
  int&& b = 1;
  f1(b);  // call f1(int&)，因为b是左值，而只能用rvalue来初始化右值引用变量，call f1(int&&)的话就违背这个规矩了；
  f1(std::move(b));  // call f1(int&&)
  return 0;
}
```
- 不能用rvalue初始化左值引用，因为左值引用的意思就是我可以帮你做一点计算（修改你），但是你一个右值马上就消亡了，我帮你计算你也拿不到结果，前后矛盾了。
- 不能用左值初始化右值引用，因为右值引用的意思就是管理权交给我，你别管了，但是你一个左值你调用完我还是能进行管理的，前后矛盾了。
- 但是为什么可以用rvalue初始化常左值引用（const T&）呢，是因为const说明我肯定不是帮你计算而仅仅是提取信息而已，你并不需要拿到结果，不矛盾。因此常左值引用既可以用rvalue初始化，又可以用左值初始化，相对比较“万能”；
- 为什么可以用右值引用初始化左值引用呢，因为右值引用是左值。。。