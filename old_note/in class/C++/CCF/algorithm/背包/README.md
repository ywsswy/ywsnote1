```
C 重量/体积/花费	限制
W 价值			目标最大化
F[i][j] 表示 选完前i种/件物品使得剩余空间为j的背包中  所能得到的最大价值
【01背包（一个物品只能放一次）
f[i][v]=max{ f[i-1][v], f[i-1][v-c[i]]+w[i] }
(一维实现 优化空间复杂度)
for i=1..N
    forv=V..0
       f[v]=max{f[v],f[v-c[i]]+w[i]};
//不一定装满 
初始f[0...V] = 0
计算顺序是：从右往左，自上而下：因为每个物品只能放一次，前面的体积小的会影响体积大的
//装满
初始f[0] = 0,f[1...V] = -inf（因为要求恰好装满）
计算顺序是：从右往左，自上而下：因为每个物品只能放一次，前面的体积小的会影响体积大的
肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值
【完全背包（一个物品可以选多次，求某容量背包能装的最大价值）
f[i][v]=max{f[i-1][v],f[i-1][v-vi]+wi}
（一维实现）
for i=1..N
    forv=0..V
       f[v]=max{f[v],f[v-cost]+weight}
【01背包与完全背包的混合
考虑到在P01和P02中给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。伪代码如下：
for i=1..N
    if 第i件物品是01背包
       for v=V..0
           f[v]=max{f[v],f[v-c[i]]+w[i]};
    else if 第i件物品是完全背包
        for v=0..V
            f[v]=max{f[v],f[v-c[i]]+w[i]};
//////////////////////////////////////////////////////////////////////
gradle设置成3.4
androidKiller
【求01不装满最大价值
重量 价值 
    n 0 1 2 3 4 5 6 7 8 9 10
    0 0 0 0 0 0 0 0 0 0 0 0
3 4 1 0 0 0 4 4 4 4 4 4 4 4 f[10] = max{f[10],f[10-3] + value[i]}
4 5 2 0 0 0 4 5 5 5 9 9 9 9 f[6] = max{f[6],f[6-4] +  5}
5 6 3 0 0 0

```