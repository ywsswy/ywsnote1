运算符重载的实质就是函数重载。在实现过程中，首先把指定的运算表达式转化为
对运算符函数的调用，将运算对象转化为运算符函数的实参，然后根据实参的类型来确定
需要调用的函数，这个过程是在编译过程中完成的。
至少要有一个操作对象是自定义类型。
c++ 标准规定，有些操作符是不能重载的，它们是
类属关系运算符"."、
成员指针运算符".*"、
作用域分辨符"::"、
三目运算符"?:"
返回类型 operator 运算符(形参表){
	函数体
}
【重载为类的非静态成员函数
1）双目运算符B ，如果要重载为类的成员函数，使之能够实现表达式。oprdl B oprd2 ，其中 oprdl 为A类的对象，则应当把B重载为A类的成员函数，该函数只有一个形参，形参的类型是 oprd2 所属的类型。表达式 oprdl B oprd2 就相当于函数调用 oprd1.operator B(oprd2)
2）前置单目运算符U ，如"-"(负号)等，如果要重载为类的成员函数，用来实现表达式 U oprd. 其中 oprd 类的对象，则U应当重载为A类的成员函数，函数没有形参。经过重载之后，表达式U oprd 相当于函数调用 oprd. operator U () 
3）后置运算符"十十"和"一一"，如果要将它们重载为类的成员函数，用来实现表达式。prd++ oprd 一一，其中 oprd 类的对象，那么运算符就应当重载为 类的成员函数，这时函数要带有一个整型(int)形参。重载之后，表达式。prd+ 十和 oprd 一一就相当于函数调用 oprd. operator 十十 (0) oprd. operator- (0) 。这里的 int 类型参数在运算中不起任何作用，只是用于区别后置与前置
【重载为非成员函数都可以
1）双目运算符 ，如果要实现 oprdl 8 oprd2 ，其中 oprdl oprd2 中只要有一个具有自定义类型，就可以将 重载为非成员函数，函数的形参为 oprdl oprd2 。经过重载之后，表达式 oprd1 B oprd2 就相当于函数调用 operator B(oprd1 oprd2)
2）前置单目运算符 U. 如"一"(负号)等，如果要实现表达式 oprd. 其中 oprd 具有
自定义类型，就可以将 重载为非成员函数，函数的形参为 oprd 经过重载之后，表达式
U oprd 相当于函数调用 operator U(oprd)
3）后置运算符++和一一，如果要实现表达式。prd ++或 oprd 一一，其中 oprd
为自定义类型，那么运算符就可以重载为非成员函数。这时函数的形参有两个，一个
op时，另一个是 int 类型形参。第二个参数是用于与前置运算符函数相区别的。重
载之后，表达式 oprd +十和 oprd 一一就相当于函数调用 operator 十十( op .0)
operator - - (oprd. 0)
;当重载为非成员函数时，参数个数与原操作数个数相同。两种情况的参数个数有所差异的原因是，重载为类的成员函数时，第一个操作数会被作为函数调用的目的对象，因此无须出现在参数表中，函数体中可以直接访问第一个操作数的成员;而重载为非成员函数时，运算符的所有操作数必须显式通过参数传递。
【注
运算符的两种重载形式各有千秋。成员函数的重载方式更加方便，但有时出于以下原因，需要使用非成员函数的重载方式。
(1)要重载的操作符的第一个操作数不是可以更改的类型，例如上例中"<<"运算
符的第一个操作数的类型为 ostream ，是标准库的类型，无法向其中添加成员函数。
(2) 以非成员函数形式重载，支持灵灵活的类型转换。例如例 8-3 中，可以直接使用
5.0+c l，因为 Complex 的构造函数使得实数可以被隐含转换为 Complex 类型。这样
5.0+cl 就会以 operator+ C ComplexC 5. 0) cl) 的方式来执行， cl 5. 也一样，从而支持
了实数和复数的相加，很方便也很直观;而以成员函数重载时，左操作数必须具有
Complex 类型，不能是实数(因为调用成员函数的目的对象不会被隐含转换) ，只有右操作
数可以是实数(因为右操作数是函数的参数，可以隐含转换)。
【eg：
	(5.0+c1[1]).show();//错
	(c1[1]+5.0).show();//对
