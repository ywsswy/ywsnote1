echo 'value[34589700]end' | perl -pe 's/value\[([0-9]*)\]/find:${1}/'
正则匹配替换，${1}表示第一个圆括号里面匹配到的内容+剩余未匹配的内容！！！上例输出是“find:34589700end”

注意分隔符必须用'/'（专门支持了转义？）否则可能会有bug

例如echo "xxx#doc_id:2X" |perl -pe 's/.*#doc_id:(\d)/${1}/' 的输出就是就是2X，而不是2，所以保险一点的验证自己正则语法是否有问题的方法是以$结尾

如果完全没有匹配的时候，则不会进行替换逻辑，直接原样输出

perl -i.bak -pe xxx <file_name> 对文件进行原地正则匹配替换修改，原文件加.bak后缀做备份

- 条件判断（e后缀可以执行代码），结果拼接输出（例如统计5秒粒度文件行数，0~4输出0，5~9输出5）
cat file |perl -pe 's/.*? (\d*?:\d*?:\d{1})(\d{1}).*$/"${1}" . ($2 <=4 ? 0 : 5)/e' |sort |uniq -c

- 常用写法：提取进程pid
ps xfu |grep wtf |perl -pe 's/.+? ([^ ]+).*/$1/'

Q：支持不可打印字符吗？