re.sub(pattern, repl, string, count=0, flags=0)
pattern : 正则中的模式字符串。
repl : 匹配的部分要替换成的字符串，也可为一个函数。
string : 原字符串。
count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。
//////////////////////////////////////////////////////////////////////
print re.sub('[^a-zA-Z]','',oldS)

把oldS串中 除了字母以外的去除掉
//////////////////////////////////////////////////////////////////////
print(re.sub(r'(.*?)(\d+)(.*)',r'\1\2 \2\3','s123t'))
#()分区域，匹配到3个部分，替换成第一部分+第二部分+第二部分+第三部分
这相当于用自身来替换，有点像 r'{0}{1}{1}{2}'.format('s','123','t')
print(re.sub(r'(.*)( )(.*)',r'\3\2\1','can you')) ### 正则匹配替换后成了'you can'
//////////////////////////////////////////////////////////////////////
【易错，别忘记转义的符号
?		re.sub(r'Pic.php?jxb=','',res)，这种就错了
【模式（假设用x代表我写的内容）
^		开头
$		结尾
.		任意字符，除换行符外（当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。）
[x]		一组，其内的任何都满足。[ad-f]就表示adef这四个都符合
[^x]		一组，不在其内的都满足
x*		匹配（0-n）次，如果再加?为非贪婪
x+		匹配（1-n）次，如果再加?为非贪婪
x{y}		匹配y次
x{y,}		匹配(y-n)次
x{y,z}		匹配(y-z）次，贪婪模式
x|y		匹配x或y
(x)		划分出来一组，见例子
\w		字母数字下划线
\W		非字母数字下划线
\s		匹配任意空白字符，等价于 [\t\n\r\f]
\S
\d
\D
\A		匹配字符串开始
\Z		匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。
\z		匹配字符串结束

【常见
.*$		任意字符贪婪匹配，匹配到结尾
