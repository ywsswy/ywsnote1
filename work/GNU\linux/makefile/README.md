# make:
make -n 只显示要执行的命令，不执行，make V=1又显示又执行
make <目标> 会自动检查当前目录makefile文件里面<目标>的依赖，不写<目标>就是构建makefile中的第一个目标


# makefile:
# 跟shell区别的地方
```
# 每一行命令会用一个单独的shell执行
所以要cd的话，应该cd ..; xxx
或者cd ..;\
xxx

# 每行命令都会回显，如果不要，则前面加上@

xxx=abc def# 注意这里好像是变量，但是更像宏定义，我称之为“宏变量”，宏变量可以存在空格，不像shell变量那样必须引号括起来
# 宏变量要求在最上面写，不能在下面的“分支”语句上定义
# 可以使用环境变量，但是变量名长度大于1的变量的使用必须用括号${xxx}，不然只有第一个字符会被解析
# 获取环境变量值长度要使用$${xxx}
```
# 预定义变量
$@ 目标的完整名称
$* 目标的名称（不含后缀名）
$% ？？如果目标是归档成员，则表示目标的归档成员名称
$^ 所有依赖文件名称，空格分开
$? 所有依赖文件名称，空格分开（依赖文件的修改日期比目标创建日期晚)
$+ 所有依赖文件名称，空格分开（可能包含重复的依赖文件？）
$< 第一个依赖文件名称


# 隐晦规则（就是所有这部分的目标生成，都不用自己写了？）
```
.SUFFIXES: .cpp .cc .c
.cpp.o:
    gcc ${CXXFLAGS} -c $<
.cc.o:
    ${CC} ${CXXFLAGS} -c $<
.c.o:
    gcc ${CFLAGS} -c $<

```

# 显式规则
```
<目标>:<依赖>
    <操作命令> #要求是tab缩进
```




# 函数使用方式
$(<function_name> [<args1>,<arg2>[,...]]

eg: SRC=$(notdif ..) #去除所有目录信息，SRC只有文件名
       =$(wildcard *..cpp) #得到所有cpp结尾的文件
