## 16个32位寄存器：

### 4个数据寄存器（EAX、EBX、ECX、EDX），6个段寄存器（ES、CS、SS、DS、FS、GS），1个标志寄存器（EFlags），

### 2个变址和指针寄存器（ESI和EDI）

### 2个指针寄存器（ESP和EBP）
- BP：（Bash Pointer/用于存放当前函数栈的基址（栈底）地址），（32位叫ebp，64位叫rbp）
- SP：（Stack Pointer/用于存放当前函数栈的栈顶地址），因为栈是从下往上增长的，所以每次push【入栈】时，esp都会往上移动一次，32位机器移动4字节，64位机器移动8字节，然后再把指写到该地址（注意是先移动再写值）；在多线程程序中，每个线程有自己的【栈空间】，然后这个线程内的函数调用每一层是会分配一个【栈帧】；

### 1个指令指针寄存器（EIP）：
- IP：当前函数指令的地址，每次执行完一条指令，IP都会指向下一条指令的地址；

## 指令介绍
- push %rbp  -- 把bp寄存器的值入栈；
- mov %rsp,%rbp  -- 把rsp赋值给rbp；第一个操作数%rdi表示该rdi寄存器的值，第一个操作数$0x3表示是一个立即数，第二个操作数-0x8(%rbp)表示rbp寄存器的值减8的内存位置
- movl $0x8, -0x24(%rbp)  -- 32位的操作数复制，这个指令是7字节，操作数占了4字节
- movq $0x8, -0x24(%rbp)  -- 64位的操作数复制，这个指令是8字节，多了一个字节表示64位，操作数仍然是4字节，只是会被扩展成8字节
- callq 40078d  -- 见函数调用说明
- leaveq  -- 见函数调用说明
- retq  -- 见函数调用说明
- lea -0x10(%rbp),%rax  -- 把某地址赋值给rax

## 汇编函数调用的流程：
### A.主调函数
- push形参（也有可能是把参数放到一些编译器约定好的寄存器中，例如lea -0x10(%rbp),%rax; mov $0x3,%esi; mov %rax,%rdi）
- callq 被调函数 没有这个函数调用的话，指令应该顺序执行的，但是现在要跳转到别处了，所以应该把下一条指令的地址记住（以便函数返回时恢复正确的IP），所以callq相当于先push下一条指令的地址，然后把IP修改为想跳转到的目标指令处的地址；

### B.被调函数开始
- push bp（保存主调函数栈基址）
- mov sp,bp（把此时的栈顶地址作为该函数的函数栈基址，然后bp在该函数内部就固定不修改了，能借此随时获取传递来的参数，例如 0x8(%ebp)就能获取第一个函数形参）

### C.被调函数内部
- sub $0x40, sp  可能会有一些局部变量需要占用一些栈空间，所以会把栈顶指针往上移动一些，sp\~bp之间的内存就可以随便玩了；<font color=red>编码时语句块结束变量就不能访问了，这只是给程序员的限制，但是编译器并没有限制，编译器并不会因为一个局部变量用不到了就进行移动栈帧等操作，可能一条汇编指令都不会产生，因为编译器自己清楚sp\~bp之间的哪些内存是被“释放”的可以继续使用的；（见下面的POD析构）</font>

### D.被调函数收尾
- leaveq 相当于（mov bp,sp; pop bp）sp\~bp之间的内存不要了，把主调函数栈基址恢复到bp里（pop【出栈】是先取值，然后再往下移动一次sp）；
- retq 相当于（pop ip），恢复函数调用之前下一条指令的地址；


## POD“析构”
下面Fun函数中的a和b的内存地址可能是复用的也可能是不同的；
虽然是2个语句块，但是不涉及栈帧的变化，只在Fun结束时移动一次sp，所以可以理解这里的“析构”几乎0开销，并没有特意为某个变量消亡做什么指令处理，而是变量随着栈帧消亡，而且栈帧消亡也并不是什么复杂的操作，仅仅是改变了两个寄存器的值！
```
class AAA {
 public:
  int v1{4};
  int v2{5};
};
void Fun() {
  {
    AAA a;
  }
  {
    AAA b;
  }
}
```


## 其他
- 低地址：0x7fffdd30
- 高地址（更大）：0x7fffdd50
- 但是一般阅读上都是从上（低地址）往下（高地址）看的，所以无特殊说明时默认就是上/小/低、下/大/高；
- 汇编语法（有Intel语法和AT&T语法，前者 mov A,B 是A<-B，后者相反，默认是用AT&T语法）
- 类内成员变量先定义的在低地址；（【Q】是否挨着？符合字节对齐就可以？）
- 函数内同一语句块内局部变量先定义的在高地址；挨着的局部变量地址可能不挨着；
- 大部分是小端存储，就是0x12345678，存成0x78 0x56 0x34 0x12