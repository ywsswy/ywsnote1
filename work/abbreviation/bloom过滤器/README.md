Bloom Filter 布隆过滤器
https://zhuanlan.zhihu.com/p/136529740

元素在插入Bloom Filter时，使用哈希函数(Hash Function)计算其哈希值确定其在位数组中的位置索引，然后将位数组中的指定Bit从0置1即可(如该Bit已经被置1，则无需再次置1)。当使用Bloom Filter判定指定元素是否存在其中时，同样利用该Hash Function先计算哈希值，确定其在位数组的中位置索引，然后取出该位置的值， 若该Bit为0，则说明该元素不存在于其中；若该Bit为1，则说明该元素存在于其中。


布隆过滤器是一种数据结构。
查询一个元素时，然后检查对应的k个比特值：如果有任意一个比特为0，表明该元素一定不在集合中；如果所有比特均为1，表明该元素有可能性在集合中。
由于可能出现哈希碰撞，导致一个不存在的元素有可能对应的比特位为1，这就是所谓“假阳性”（false positive）


该数据结构涉及到的一些参数指标：
n/记录item条数上限，如果超限制了怎么办，所以设计上通常是一个布隆过滤器中维护多个布隆块，每个块维护单独的nmpk，一个块写满或者达到设置的滚动时间，就会新增一个块往新的里面写；
P/误判率/假阳率
m/比特数组的长度
k/hash函数的个数
为了节约存储成本，布隆过滤器的序列化数据通常有配置化是否可压缩、过滤器类型、布隆快个数等参数（放到footer结构里），所以一般存储的是footer+序列化数据，解析时先解析footer，然后再决定怎么解析序列化数据，解析序列化数据的时候每一个块还可以有一个meta（保存上述的mnpk等所需参数）


通常配置n和p，服务会自动计算出合适的参数m和参数k；(https://en.wikipedia.org/wiki/Bloom_filter#Alternatives)
m = - std::log2(p) * 50 / std::log(2)
k = std::log(2) * m / n
n越大，p要求越小，对应的存储和计算成本会增长