### 建立连接（三次握手）

|客户端套接字（可以netstat查看）状态|客户端发送的数据|服务端发送的数据|服务端（套接字）状态|ps|
|-|-:|:-|-|-|
| | | |LISTEN|
| |SYN=1,ACK=0,seq=x,len=0|->| |只有建立连接的时候才会看到SYN的置位，其他正常数据传输时不会|
|发送完变成SYNSENT|
| | | |收到后变成SYNRCVD|
| |<-|SYN=1,ACK=1,seq=y,ack=x+1,len=0| |这里之所以+1是因为SYN不携带数据也消耗一个序号?|
|收到后变成ESTABLISHED|
| |ACK=1,seq=x+1,ack=y+1,len=0|->| |这里之所以两处+1是因为SYN不携带数据也消耗一个序号?|
| | | |收到后变成ESTABLISHED|之所以需要客户端再告知一次确认，是考虑到网络可能存在数据传输滞留，万一服务端收到的是很久前的一次连接请求，并不应该立刻建立连接以免浪费资源|


### 释放连接（四次握手）

|A端（主动释放方）套接字状态|A端发送的数据|B端发送的数据|B端（套接字）状态|ps|
|-|-:|:-|-|-|
|ESTABLISHED| | |ESTABLISHED|之所以称为A/B端，而不是客户端/服务端，是因为任意一端都可以主动释放连接|
|-|FIN=1,ACK=1,seq=x,len=s|->| |seq表示我这次发送的字节序号是[seq,seq+len),ack表示我已经收到你发送的字节序号[.,ack),期望你下一次发送的字节序号从ack(含)开始<br>通常len是0，但是http服务端的应用层响应数据和FIN可能混在一个数据报里，此时len就不为0；|
|发送完变成FIN-WAIT-1| | | |而且A方从现在开始已经不会发送“应用层”的数据了（但还能收B过来的）|
| | | |收到后变成CLOSE-WAIT|
| |<-|ACK=1,ack=x+s+1| |B立马回复ack就跟正常收到数据时的回复是同样的；接下来B可能还会继续把一些“应用层”的数据发送完，可以持续一段时间；<br>普通数据传输时不需要+1，这里之所以+1是因为tcp规定即使FIN不携带数据也消耗一个序号|
|收到后变成FIN-WAIT-2|
| |<-|FIN=1,ACK=1,seq=y,ack=x+s+1|
| | | |发送完变成LAST-ACK|
|收到后变成TIME-WAIT<br>2MSL(RFC793建议4分钟)后释放(CLOSED)|
| |ACK=1,seq=x+s+1,ack=y+1|->|
| | | |收到后释放(CLOSED)|



<style type="text/css">
td{
    border: 1px solid #000;
}
</style>
