如果涉及到对get的数据做处理后再set时，
就存在并发问题；

一种简单方案是get的节点在之前尝试加锁setnx，处理完set之后再释放锁；

还有一种方案是数据中存储版本号（例如前四个字节），每次处理版本号要加一，set使用lua脚本进行set，脚本逻辑是get存储中的四个字节，判断是否等于当前传入的新值的版本号减一，是说明没有并发改动则写如数据，否则说明有其他线程已经set过了则应返回错误码，重新发起get和set操作；

当然逻辑简单的情况下也可以全程用lua脚本实现

lua脚本不是真的事务（不存在回滚等操作），
实现的原理是比较暴力的“伪”事务，就是一个lua执行的过程中，其他任何命令都不处理，显然并发性能很差;

