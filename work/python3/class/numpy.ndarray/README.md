【创建
y1 = numpy.array([i for i in range(10)])
<class 'numpy.ndarray'>
只能存一种类型的数据
numpy里的向量，可以是任意维度的
array([[-1.35359057, -1.79442111],
       [-2.08696103, -0.50632781],
       [-2.29379904,  0.95491265]])#这是一个3行2列的二维向量
shape 为 (3, 2)
【访问
下标从0开始
推荐用元组定位
x[(3,2)]#第4行，第3列 
x[3,2]#同上，
访问切片相同
x[:5]
x[::2]#步长
a = numpy.array([['1','2'],['3','4']])
a[1]#第二行b = a[1]，对b操作，a也会变
a[:,1]#第二列
访问[start:end:step)	#下标，start闭，end开，step为负，则是
原理是，
1）
判断start是否为负，为负就计算其对应的正值，
比如下标是0~4，-1就为4，-5就为0，-8就为-∞，5就为+∞
2）
step为负时start要大于end
step为正时start要小于end
3）
计算每个下标
i = 0
start+step*i
//////////////////////////////////////////////////////////////////////
子矩阵、对象自动引用（为了速率着想），复制应该完全拷贝(.copy())才行
//////////////////////////////////////////////////////////////////////
交换矩阵中的两行
z = np.arange(25).reshape(5,5)
z[[0,1]] = z[[1,0]]
z
1）用 bool掩码 提取（副本）
a = numpy.array([1,2,3])
b = numpy.array([1,1,0],dtype=bool)
c = a[b]  #array([1, 2])
2）用条件获取 下标索引或者（bool掩码），然后用下标索引或者（bool掩码）提取（副本）
a = numpy.array([1,2,3])
b = a > 1 #array([False,  True,  True], dtype=bool)
c = numpy.where(b) #(array([1, 2], dtype=int64),)
a[b]
或者
a[c]

